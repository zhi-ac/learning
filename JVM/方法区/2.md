## 4.方法区的内部结构
### 4.1 方法区结构
![image](https://user-images.githubusercontent.com/59955759/122626605-147d3880-d0de-11eb-909b-ef57906ebd5b.png)
《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。
![image](https://user-images.githubusercontent.com/59955759/122626611-1c3cdd00-d0de-11eb-8eb0-76c342dd844b.png)
### 4.1.1 类型信息
对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：
* 这个类型的完整有效名称（全类名=包名.类名）
* 这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）
* 这个类型的修饰符（public，abstract，final的某个子集）
* 这个类型直接接口的一个有序列表
### 4.1.2 域（Field）信息
* JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。
* 域信息通俗来讲是类的成员变量
* 域的相关信息包括：
  * 域名称
  * 域类型
  * 域修饰符（public，private，protected，static，final，volatile，transient的某个子集）
### 4.1.3 方法（Method）信息
* 方法名称
* 方法的返回类型（包括 void 返回类型），void 在 Java 中对应的类为 void.class
* 方法参数的数量和类型（按顺序）
* 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）
* 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）
* 异常表（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引
代码示例
~~~
/**
 * 测试方法区的内部构成
 */
public class MethodInnerStrucTest extends Object implements Comparable<String>, Serializable {
    //属性
    public int num = 10;
    private static String str = "测试方法的内部结构";

    //构造器没写

    //方法
    public void test1() {
        int count = 20;
        System.out.println("count = " + count);
    }

    public static int test2(int cal) {
        int result = 0;
        try {
            int value = 30;
            result = value / cal;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return result;
    }

    @Override
    public int compareTo(String o) {
        return 0;
    }
}

~~~
> 反编译字节码文件，并输出到文本文件中，便于查看
> 参数 -p 确保能查看 private 权限类型的字段或方法

~~~
javap -v -p MethodInnerStrucTest.class > Text.txt
~~~
### 类型信息
* 在运行时方法区中，类信息中记录了哪个加载器加载了该类，同时类加载器也记录了它加载了哪些类
* 从反编译文件可以看出，字节码文件记录了 MethodInnerStrucTest 继承了哪些类，实现了哪些方法
~~~
//类型信息
public class cn.sxt.java.MethodInnerStrucTest extends java.lang.Object
implements java.lang.Comparable<java.lang.String>, java.io.Serializable
~~~
### 域信息
* descriptor: I 表示字段类型为 Integer
* flags: ACC_PUBLIC 表示字段权限修饰符为 public

~~~
//域信息
  public int num;
    descriptor: I
    flags: ACC_PUBLIC

  private static java.lang.String str;
    descriptor: Ljava/lang/String;
    flags: ACC_PRIVATE, ACC_STATIC
~~~
### 方法信息

* descriptor: ( )V 表示方法返回值类型为 void
* flags: ACC_PUBLIC 表示方法权限修饰符为 public
* stack=3 表示操作数栈深度为 3
* locals=2 表示局部变量个数为 2 个（实例方法包含 this）
* test1( ) 方法虽然没有参数，但是其 args_size=1 ，这是因为将 this 作为了参数
~~~
public void test1();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=2, args_size=1
         0: bipush        20
         2: istore_1
         3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
         6: new           #4                  // class java/lang/StringBuilder
         9: dup
        10: invokespecial #5                  // Method java/lang/StringBuilder."<init>":()V
        13: ldc           #6                  // String count =
        15: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
        18: iload_1
        19: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
        22: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
        25: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        28: return
      LineNumberTable:
        line 17: 0
        line 18: 3
        line 19: 28
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      29     0  this   Lcn/sxt/java/MethodInnerStrucTest;
            3      26     1 count   I
~~~

## 4.2 域信息特殊情况
> non-final 类型的类变量

* 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分
* 类变量被类的所有实例共享，即使没有类实例时，你也可以访问它

代码示例
* 如下代码所示，即使我们把order设置为null，也不会出现空指针异常
* 这更加表明了 static 类型的字段和方法随着类的加载而加载，并不属于特定的类实例

~~~
/**
 * non-final的类变量
 */
public class MethodAreaTest {
    public static void main(String[] args) {
        Order order = null;
        order.hello();
        System.out.println(order.count);
    }
}

class Order {
    public static int count = 1;
    public static final int number = 2;


    public static void hello() {
        System.out.println("hello!");
    }
}
~~~
程序运行结果

~~~
hello!
1
~~~

全局常量：static final

* 全局常量就是使用 static final 进行修饰
* static 和 static final 其中static final 在 编译时就已经初始化

代码示例

~~~
class Order {
    public static int count = 1;
    public static final int number = 2;


    public static void hello() {
        System.out.println("hello!");
    }
}

~~~

反编译，查看字节码指令，可以发现 number 的值已经写死在字节码文件中了

~~~

  public static int count;
    descriptor: I
    flags: ACC_PUBLIC, ACC_STATIC

  public static final int number;
    descriptor: I
    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL
    ConstantValue: int 2

~~~

## 4.3 运行时常量池
运行时常量池 VS 常量池
* **方法区，内部包含了运行时常量池**
* **字节码文件，内部包含了常量池**
* 要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。
* 要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。

![image](https://user-images.githubusercontent.com/59955759/122627188-8d7d8f80-d0e0-11eb-9547-3569779440a9.png)
常量池

* 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外
* 还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用


![image](https://user-images.githubusercontent.com/59955759/122627230-c453a580-d0e0-11eb-9671-20e2229abd70.png)

~~~
为什么需要常量池？
~~~


* 一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池
* 这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍
* 比如：如下的代码：
~~~
public class SimpleClass {
    public void sayHello() {
        System.out.println("hello");
    }
}

~~~

* 虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。
* 如果不使用常量池，就需要将用到的类信息、方法信息等记录在当前的字节码文件中，造成文件臃肿
* 所以我们将所需用到的结构信息记录在常量池中，并通过引用的方式，来加载、调用所需的结构
* 这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。

![image](https://user-images.githubusercontent.com/59955759/122627302-23191f00-d0e1-11eb-9722-f57ae725e61c.png)

### 常量池中有什么？

* 数量值
* 字符串值
* 类引用
* 字段引用
* 方法引用

常量池代码举例
~~~
/**
 * 测试方法区的内部构成
 */
public class MethodInnerStrucTest extends Object implements Comparable<String>, Serializable {
    //属性
    public int num = 10;
    private static String str = "测试方法的内部结构";

    //构造器没写

    //方法
    public void test1() {
        int count = 20;
        System.out.println("count = " + count);
    }

    public static int test2(int cal) {
        int result = 0;
        try {
            int value = 30;
            result = value / cal;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return result;
    }

    @Override
    public int compareTo(String o) {
        return 0;
    }
}

~~~

* 来看下最简单的 test1( ) 方法，带 # 的字节码指令，就使用到了常量池的引用
* 通过字节码指令可以看出，拼接字符串时，编译器帮我们造了个 StringBuilder 对象，然后调用其 append( ) 方法完成了字符串的拼接

~~~
public void test1();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=2, args_size=1
         0: bipush        20
         2: istore_1
         3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
         6: new           #4                  // class java/lang/StringBuilder
         9: dup
        10: invokespecial #5                  // Method java/lang/StringBuilder."<init>":()V
        13: ldc           #6                  // String count =
        15: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
        18: iload_1
        19: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
        22: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
        25: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        28: return
      LineNumberTable:
        line 17: 0
        line 18: 3
        line 19: 28
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      29     0  this   Lcn/sxt/java/MethodInnerStrucTest;
            3      26     1 count   I

~~~

* 常量池
~~~
Constant pool:
   #1 = Methodref          #18.#52        // java/lang/Object."<init>":()V
   #2 = Fieldref           #17.#53        // cn/sxt/java/MethodInnerStrucTest.num:I
   #3 = Fieldref           #54.#55        // java/lang/System.out:Ljava/io/PrintStream;
   #4 = Class              #56            // java/lang/StringBuilder
   #5 = Methodref          #4.#52         // java/lang/StringBuilder."<init>":()V
   #6 = String             #57            // count =
   #7 = Methodref          #4.#58         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
   #8 = Methodref          #4.#59         // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
   #9 = Methodref          #4.#60         // java/lang/StringBuilder.toString:()Ljava/lang/String;
  #10 = Methodref          #61.#62        // java/io/PrintStream.println:(Ljava/lang/String;)V
  #11 = Class              #63            // java/lang/Exception
  #12 = Methodref          #11.#64        // java/lang/Exception.printStackTrace:()V
  #13 = Class              #65            // java/lang/String
  #14 = Methodref          #17.#66        // cn/sxt/java/MethodInnerStrucTest.compareTo:(Ljava/lang/String;)I
  #15 = String             #67            // 测试方法的内部结构
  #16 = Fieldref           #17.#68        // cn/sxt/java/MethodInnerStrucTest.str:Ljava/lang/String;
  #17 = Class              #69            // cn/sxt/java/MethodInnerStrucTest
  #18 = Class              #70            // java/lang/Object
  #19 = Class              #71            // java/lang/Comparable
  #20 = Class              #72            // java/io/Serializable
  #21 = Utf8               num
  #22 = Utf8               I
  #23 = Utf8               str
  #24 = Utf8               Ljava/lang/String;
  #25 = Utf8               <init>
  #26 = Utf8               ()V
  #27 = Utf8               Code
  #28 = Utf8               LineNumberTable
  #29 = Utf8               LocalVariableTable
  #30 = Utf8               this
  #31 = Utf8               Lcn/sxt/java/MethodInnerStrucTest;
  #32 = Utf8               test1
  #33 = Utf8               count
  #34 = Utf8               test2
  #35 = Utf8               (I)I
  #36 = Utf8               value
  #37 = Utf8               e
  #38 = Utf8               Ljava/lang/Exception;
  #39 = Utf8               cal
  #40 = Utf8               result
  #41 = Utf8               StackMapTable
  #42 = Class              #63            // java/lang/Exception
  #43 = Utf8               compareTo
  #44 = Utf8               (Ljava/lang/String;)I
  #45 = Utf8               o
  #46 = Utf8               (Ljava/lang/Object;)I
  #47 = Utf8               <clinit>
  #48 = Utf8               Signature
  #49 = Utf8               Ljava/lang/Object;Ljava/lang/Comparable<Ljava/lang/String;>;Ljava/io/Serializable;
  #50 = Utf8               SourceFile
  #51 = Utf8               MethodInnerStrucTest.java
  #52 = NameAndType        #25:#26        // "<init>":()V
  #53 = NameAndType        #21:#22        // num:I
  #54 = Class              #73            // java/lang/System
  #55 = NameAndType        #74:#75        // out:Ljava/io/PrintStream;
  #56 = Utf8               java/lang/StringBuilder
  #57 = Utf8               count =
  #58 = NameAndType        #76:#77        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
  #59 = NameAndType        #76:#78        // append:(I)Ljava/lang/StringBuilder;
  #60 = NameAndType        #79:#80        // toString:()Ljava/lang/String;
  #61 = Class              #81            // java/io/PrintStream
  #62 = NameAndType        #82:#83        // println:(Ljava/lang/String;)V
  #63 = Utf8               java/lang/Exception
  #64 = NameAndType        #84:#26        // printStackTrace:()V
  #65 = Utf8               java/lang/String
  #66 = NameAndType        #43:#44        // compareTo:(Ljava/lang/String;)I
  #67 = Utf8               测试方法的内部结构
  #68 = NameAndType        #23:#24        // str:Ljava/lang/String;
  #69 = Utf8               cn/sxt/java/MethodInnerStrucTest
  #70 = Utf8               java/lang/Object
  #71 = Utf8               java/lang/Comparable
  #72 = Utf8               java/io/Serializable
  #73 = Utf8               java/lang/System
  #74 = Utf8               out
  #75 = Utf8               Ljava/io/PrintStream;
  #76 = Utf8               append
  #77 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;
  #78 = Utf8               (I)Ljava/lang/StringBuilder;
  #79 = Utf8               toString
  #80 = Utf8               ()Ljava/lang/String;
  #81 = Utf8               java/io/PrintStream
  #82 = Utf8               println
  #83 = Utf8               (Ljava/lang/String;)V
  #84 = Utf8               printStackTrace

~~~

> 常量池总结
常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息

> 运行时常量池

* 运行时常量池（Runtime Constant Pool）是方法区的一部分。
* 常量池表（Constant Pool Table）是Class字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
* 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。
* JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。
* 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。
* 运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。
* 运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。
* 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。





